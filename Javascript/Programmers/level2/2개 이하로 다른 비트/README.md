# [문제](https://school.programmers.co.kr/learn/courses/30/lessons/77885#)

# 처음 생각한 풀이법

- 문제에 있는 그대로 현재 수를 이진수로 바꾸고 더 큰 수들을 차례대로 이진수로 바꿔서 서로 다른 비트가 몇 개 있는지 판별

# 틀렸다면 이후 풀이 방법 및 참고 자료

- 그대로 구현하면 시간초과가 나는 케이스가 있었다. 아무리 줄이려고 했어도 시간초과가 났다.
- 질문하기 페이지를 보고 힌트를 얻었다. 이진수에서 다른 비트가 2개 이하이면서 가장 작은 수를 찾으려면 해당 수를 이진수로 변환한 후 가장 오른쪽에 있는 ‘0’ 비트를 찾아서 그 오른쪽의 ‘1’ 비트와 바꿔주면 된다.
    - ‘0’ 비트가 없는 경우 ‘1’ 비트를 맨 앞에 추가하고 그 뒤 비트를 ‘0’으로 바꿔주면 된다.(앞쪽에 있을수록 큰 비트이기 때문에)
    - ‘0’비트가 맨 끝에 있는 경우 그 비트를 1로 바꿔주면 된다.
    - 이렇게 했는데도 오류가 났는데 그 이유가 숫자가 0이거나 1일 때 서로 다르게 동작해야 하는데 내가 짱 코드에서는 둘이 어쩔 수 없이 같은 방식으로 변환하도록 해놨기 때문이다. 따라서 그 둘을 다르게 동작하는 식으로 조건을 추가해서 풀 수 있었다.