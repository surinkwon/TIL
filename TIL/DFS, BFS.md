# DFS, BFS

## DFS

- 그래프 탐색을 할 때 시작 정점에서부터 이어져있는 하나의 경로를 더 이상 갈 수 없을 때까지 탐색한 뒤 마지막 정점에서부터 다시 한 정점씩 거슬러 올라가며 해당 정점에서 다시 경로를 찾아 끝까지 탐색해나가는 방법

- 구현

  1. 탐색 경로 리스트, 방문 리스트, 스택 생성

  2. 방문 리스트와 스택과 탐색 경로 리스트에 시작점을 추가

  3. 시작점과 인접한 정점 중 하나를 고르고 그 정점에 방문한 적이 없으면 스택과 방문 리스트와 탐색 경로 리스트에 추가

  4. 해당 정점을 새로운 시작점으로 하여 2, 3 반복
  5. 더 이상 갈 수 있는 정점이 없으면 스택을 팝하고 다시 스택 탑을 시작점으로 하여 2, 3, 4 반복
  6. 스택이 비게 되면 방문 가능한 모든 정점을 방문 한 것

*백준 문제 1260에서 구현한 DFS 함수*

```python
def dfs(start, c):
    visited = [0]           # 방문 리스트
    stack = [0] * len(c)    # 스택
    # 스택 탑 인덱스, 탑을 -1로 설정하면 탑 +1을 하고 스택에 시작점을 추가해야 하기 때문에
    # 처음부터 0으로 지정해줌
    top = 0 
    visited[0] = start      # 방문리스트와 스택에 시작점 추가
    stack[top] = start
    k = 0                   # k는 해당 정점에서 방문할 수 있는 정점 리스트의 인덱스를 의미

    # 스택이 비어있지 않는 동안, 갈 수 있는 경로가 있는 동안
    while top > -1:

        # 해당 정점에서 갈 수 있는 정점이 있는지 조회
        # K의 범위를 지정해주는 이유는 인덱스 에러를 방지하기 위함
        if c[stack[top]] and k < len(c[stack[top]]):

            # 갈 수 있는 정점이 아직 방문하지 않은 정점이면
            if  c[stack[top]][k] not in visited:
                visited.append(c[stack[top]][k])    # 방문 리스트에 해당 정점 추가
                point = stack[top]                  # 현재 정점은 스택의 탑에 있는 정점
                top += 1                            # 스택에 방문할 수 있는 정점 push
                stack[top] = c[point][k]
                # 스택에 push한 정점으로 이동하면 그 정점에서 방문할 수 있는 정점을 처음부터 조회해야 하므로
                # 초기화해줌
                k = 0 

            # 갈 수 있는 정점이 이미 방문한 정점이라면 다른 갈 수 있는 정점을 찾음
            else:
                k += 1
        
        # 더이상 갈 수 있는 정점이 없으면 pop하고 해당 정점부터 다시 탐색
        else:
            top -= 1
            k = 0

    return visited
```



## BFS

- 시작점과 인접한 정점을 모두 방문한 후 그정점들의 인접 정점들을 모두 방문하며 탐색하는 방법
- 구현
  1. 탐색 경로 리스트, 방문 리스트, 큐 생성
  2. 탐색 경로 리스트와 방문리스트, 큐에 시작점 추가
  3. 디큐(프론트의 값을 가져옴)한 후 해당 정점을 기준으로 인접 정점을 모두 조회
  4.  각 인접 정점이 아직 방문하지 않은 곳이라면 탐색 경로 리스트, 방문 리스트, 큐에 추가 / 3, 4 반복
  5. 큐가 비었다면 모든 정점을 탐색한 것
- 최단 경로를 쉽게 찾을 수 있다.

*백준 문제 1260에서 구현한 BFS 함수*

```python
def bfs(s, c):
    visited = [0]               # 방문 리스트
    queue = [0] * len(c)        # 큐
    qf = -1
    qr = 0                      # 스택 탑과 같은 이유로 처음에는 0으로 설정
    visited[0] = S              # 방문 리스트와 큐에 시작점 추가
    queue[qr] = s

    while qf != qr:                             # 큐가 비어있지 않으면, 갈 수 있는 정점이 있으면
        qf += 1                                 # 디큐한 후 해당 정점을 기준으로 삼음
        point = queue[qf]

        if c[point]:                            # 기준 정점에서 갈 수 있는 정점이 있으면
            for i in range(len(c[point])):      # 갈 수 있는 모든 정점을 조회
                if c[point][i] not in visited:  # 아직 방문하지 않은 정점이라면
                    visited.append(c[point][i]) # 방문 리스트에 추가 및 인큐
                    qr += 1
                    queue[qr] = c[point][i]
    
    return visited
```