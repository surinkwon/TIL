'''
물병은 같은 양일 때만 다른 물병으로 부을 수 있는데 그러면 물병 안에는 항상 2의 제곱수만큼의 물이 담기게 된다. 
따라서 인덱스를 제곱수로 하는 리스트를 하나 만들어주고 이를 이용하여 문제를 풀었다.
문제에서 주어진 최대 물의 양은 10^7이므로 처음에는 리스트의 크기를 25로 했는데(1000만이 조금 넘는 수)
풀다보니 정답이 없는 경우도 체크를 해야되어 더 크게 만들었다.

물병의 개수를 줄이기 위해서는 물을 더해서 더 많은 양의 물로 만들어 그 위의 물병과 합치는 수밖에 없다.
그러려면 홀수개의 물병이 있는 물의 양만큼 상점에서 사와야 한다. 그러면 한 단계 더 많은 양의 물병이
될 수 있다.

'''

N, K = map(int, input().split())
# 인덱스를 제곱수로 하는 리스트
bottle = [0] * 40
water = N
total = 0

# 할 수 있는 한 모든 물병의 물을 합쳤을 때 몇리터의 물이 몇 개가 만들어지는 지를 bottle에 저장
# 2개가 합쳐지면 더 많은 양의 물이 담긴 물병이 되므로 결국 저장되는 값은 0, 1밖에 없음
for i in range(len(bottle)):
    bottle[i] = water % 2
    water //= 2
    if water == 0:
        break

for i in range(len(bottle)):
    # 만약 해당 물의 양에 물병이 있으면
    if bottle[i]:
        # 그 시점에서 물병의 개수를 셌을 때 목표치보다 많으면 연산
        if bottle.count(1) > K:
            # 더 많은 양의 물병이 되려면 해당 시점의 물의 양만큼 더해줘야 하므로
            # 상점에서 사옴
            total += 2 ** i
            bottle[i] = 0 # 그 양만큼 더해줬으니 지금 물의 양이 담긴 병은 없어짐
            j = 1

            # 반복문을 쓴 이유는 한 단계 더 많은 양의 물병이 되었을 때 이미 그 만큼의 물을 담은
            # 물병이 있으면 다시 더해서 그 윗 단계의 물병이 되기 때문에
            # 다음 단계에 물병이 없을 때까지 해당 단계는 물병이 0개가 되고 마지막 단계의 물병만 한 개가 됨
            while bottle[i + j]:
                bottle[i + j] = 0
                j += 1
            bottle[i + j] = 1
        else:
            break
    
    # 최대 물의 양은 2^25보다 적은데 이를 넘어가면 결국 만들 수 없음 이라고 생각해서 넣었는데...
    # 근데 생각해보면 그런 경우는 없다. 무한대로 물을 담을 수 있기 때문에 
    # 붓다보면 결국엔 물병 하나만 남게 된다.
    if i > 25:
        total = -1
        break

print(total)

