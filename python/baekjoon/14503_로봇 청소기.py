'''
테스트케이스는 제대로 나와서 잘 구현한 것 같았는데 사실 아니었다. 
그 이유는 델타 리스트를 잘못 만들었기 때문이다. 0이 북, 1이 동, 2가 남, 3이 서쪽방향
이렇게 정보가 들어오는데 나는 처음부터 그냥 방향 입력받은 값의 왼쪽을 탐색하려고 
서, 북, 동, 남 이렇게 델타 리스트를 만들어놨었다. 그리고 구현을 할 때 인덱스를 1 증가시키며
방향을 탐색하도록 했는데 생각해보면 증가가 아니라 감소가 되게 해야 방향이 바뀔 때마다 왼쪽을 탐색하는 것이 된다.
또 아예 처음부터 방향을 바꿔놨다는 것을 잊어버리고 while문 안에서는 처음 공간을 청소하면 그 다음 방향을
탐색하도록 해서 사실은 왼왼쪽을 탐색하는 방식으로 짰었다.
이것을 알아차리고 델타 리스트를 북쪽 기준으로 북, 서, 남, 동으로 짠다음 들어오는 정보와 실제 리스트의
정보를 일치시켜주는 과정을 추가해서 문제를 해결했다.
'''

dr = [-1, 0, 1, 0]
dc = [0, -1, 0, 1]

total = 0
N, M = map(int, input().split())
r, c, d = map(int, input().split())
room = [list(map(int, input().split())) for _ in range(N)]
nr = r
nc = c

# 동쪽과 서쪽은 입력받는 값과 실제 리스트 인덱스 값이 달라서 이를 처리
if d == 3:
    d = 1
elif d == 1:
    d = 3


while True:
    # 청소 안했으면 함
    if room[nr][nc] == 0:
        r = nr
        c = nc
        room[r][c] = 2
        total += 1

    # 다음 방향 탐색 전 네 방향이 모두 청소돼있거나 벽이면
    if room[r][c + 1] and room[r][c - 1] and room[r + 1][c] and room[r - 1][c]:
        # 뒤쪽도 벽이면 청소 끝
        if room[r+dr[(d + 2) % 4]][c+dc[(d + 2) % 4]] == 1:
            break
        # 뒤쪽이 벽이 아니면 후진하고 방향을 변화시키지 않음
        elif room[r+dr[(d + 2) % 4]][c+dc[(d + 2) % 4]] == 2:
            r += dr[(d+2) % 4]
            c += dc[(d + 2) % 4]
            continue

    d = (d + 1) % 4

    nr = r + dr[d]
    nc = c + dc[d]

print(total)
